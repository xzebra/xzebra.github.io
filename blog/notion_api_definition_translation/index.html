<!DOCTYPE html><html lang="en" dir="auto"><head><meta charset="utf-8"/><meta http-equiv="x-ua-compatible" content="IE=edge"/><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"/><meta name="robots" content="index, follow"/><title>Notion API definition translation | Zebra</title><meta name="keywords" content="notion,api,translation,golang,typescript"/><meta name="description" content="Using Typescript Compiler API to generate Golang structs from official Notion SDK."/><meta name="author" content="Zebra"/><link rel="canonical" href="https://xzebra.dev/blog/notion_api_definition_translation/"/><link crossorigin="anonymous" href="/assets/css/stylesheet.523aabfa2b5ee217ac92d035cb44bf463d5d30a14b08f7aa59ccfdbebf4501f8.css" integrity="sha256-Ujqr+ite4hesktA1y0S/Rj1dMKFLCPeqWcz9vr9FAfg=" rel="preload stylesheet" as="style"/><script defer="" crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload="hljs.initHighlightingOnLoad()"></script>
<link rel="icon" href="https://xzebra.dev/images/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="https://xzebra.dev/images/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="https://xzebra.dev/images/favicon-32x32.png"/><link rel="apple-touch-icon" href="https://xzebra.dev/images/apple-touch-icon.png"/><link rel="mask-icon" href="https://xzebra.dev/safari-pinned-tab.svg"/><meta name="msapplication-TileColor" content="#2e2e33"/><link rel="alternate" hreflang="en" href="https://xzebra.dev/blog/notion_api_definition_translation/"/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Notion API definition translation"/><meta property="og:description" content="Using Typescript Compiler API to generate Golang structs from official Notion SDK."/><meta property="og:type" content="article"/><meta property="og:url" content="https://xzebra.dev/blog/notion_api_definition_translation/"/><meta property="og:image" content="https://xzebra.dev/images/posts/prod-files-secure.s3.us-west-2.amazonaws.com_85SE8sZ.png"/><meta property="article:section" content="blog"/><meta property="article:published_time" content="2021-10-06T22:42:00+07:00"/><meta property="article:modified_time" content="2023-05-13T11:20:00+07:00"/><meta property="og:site_name" content="Zebra"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:image" content="https://xzebra.dev/images/posts/prod-files-secure.s3.us-west-2.amazonaws.com_85SE8sZ.png"/><meta name="twitter:title" content="Notion API definition translation"/><meta name="twitter:description" content="Using Typescript Compiler API to generate Golang structs from official Notion SDK."/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://xzebra.dev/blog/"},{"@type":"ListItem","position":2,"name":"Notion API definition translation","item":"https://xzebra.dev/blog/notion_api_definition_translation/"}]}</script><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","headline":"Notion API definition translation","name":"Notion API definition translation","description":"Using Typescript Compiler API to generate Golang structs from official Notion SDK.","keywords":["notion","api","translation","golang","typescript"],"articleBody":"Sometimes API bindings are not officially generated for all languages. Generating code from an API definition makes the binding process of an API a much more simple process than translating it field by field and function by function. When there is no public API definition, one way to overcome those problems is by translating from official code definitions.\nBackground This blog is currently being written in Notion and deployed automatically every night in a Github Action. See my last project to know more about this.\nThe mentioned project currently uses a library written in Go to communicate with Notion‚Äôs API. Although, this library is being updated by contributing users (not working for Notion) and it makes it hard to stay updated to the official API; and copying definitions by hand introduces many unnoticeable bugs.\nProposed Solution One possible solution I read was using Wasmer to create bindings to the Typescript API, so any language (that supports Wasmer) could create bindings over that WebAssembly runtime. This solution has portability as its main trait. I automatically discarded this option because, as you could have guessed, it has the extreme overhead of depending on a WebAssembly runtime; which is a lot for such a small API.\nAnother solution, proposed by one of the library contributors, was generating the structs based on the official implementation of the API. This would solve all of this problems; and also reduce significantly the amount of time to keep up to date.\nGenerating structs based on the typescript types from the official JS sdk ¬∑ Issue #10 ¬∑ jomei/notionapi After going back and forth on #9, it feels like making sure the API reference is properly implemented is a quite meticulous task that is quite error prone and may introduce vicious bugs that will b... https://github.com/jomei/notionapi/issues/10 This proposed solution mentioned a really interesting method used by the LSP implementation of Go, gopls. Too keep up with the protocol definition of Language Server Protocol (written in typescript), they use the typescript compiler API to inspect the definitions and generate Go code from these.\nAt first, I thought it was a crazy idea (well, I still think it). But I couldn‚Äôt hold myself from trying to implement it, so here is how it went.\nImplementation There are a lot of questions regarding how to translate Typescript type definitions to have usable code and with the same quality as handmade translations.\nType aliases Notion‚Äôs SDK uses Typescript‚Äôs type aliases to define the model types of the communication between client and API.\ntype IdRequest = string | string type TextRequest = string type RichTextItemRequest = | { text: { content: string; link?: { url: TextRequest } | null } type?: \"text\" annotations?: { bold?: boolean italic?: boolean strikethrough?: boolean underline?: boolean code?: boolean color?: | \"default\" | \"gray\" | \"brown\" | \"orange\" | \"yellow\" | \"green\" | \"blue\" | \"purple\" | \"pink\" | \"red\" | \"gray_background\" | \"brown_background\" | \"orange_background\" | \"yellow_background\" | \"green_background\" | \"blue_background\" | \"purple_background\" | \"pink_background\" | \"red_background\" } } ... We can easily loop for each type alias in a file using the compiler API.\nThe problem comes with getting the type representation of those. To simplify the AST types, I created two structs: one to hold a type definition and another for attributes definition.\ninterface TypeDef { id?: string; // type will be defined if it is a basic type. type?: string; // value will be defined if it is a literal type value?: any; // attributes will be defined if it is a type literal. attributes?: AttribDef[]; level?: number; isInterface?: boolean; } ... interface AttribDef { id: string; optional?: boolean; type: TypeDef; jsonName?: string; } First of all, sorry for the all optional properties, but I don‚Äôt know the idiomatic ways. This structs store some useful information about the types: where are they defined, which identifier and even a value if they are a constant.\nThe next step seems easy, just navigate the AST recursively storing the types represented with this structs. But reality strikes when you get deeper into Typescript type aliases declarations.\ntype BlockObjectRequest = | { heading_1: { text: Array\u003cRichTextItemRequest\u003e } type?: \"heading_1\" object?: \"block\" } | { heading_2: { text: Array\u003cRichTextItemRequest\u003e } type?: \"heading_2\" object?: \"block\" } | { heading_3: { text: Array\u003cRichTextItemRequest\u003e } type?: \"heading_3\" object?: \"block\" } | { embed: { url: string; caption?: Array\u003cRichTextItemRequest\u003e } type?: \"embed\" object?: \"block\" } The code above is an example of a type alias used to define blocks in Notion. For someone who hasn‚Äôt touched Typescript ever (like me until 5 days ago), those vertical lines mean it is a union type.\nUnion types A union type is a type that can be any of the sub-types in the union. Trying to express the concept of a union type is difficult in Go.\nWhat it is being done in the Go version of the API is defining an interface type Block and implement concrete types for each of the sub-types of the union, such as Heading1, Heading2‚Ä¶ Those concrete types implement the interface.\nThe important concept of this is that we have to extract an interface with the common attributes of the union (in the previous example, type and object attributes). Also, we will later have to decide the name of the concrete types.\nCreating the interface In order to create the interface, we will iterate all the children AST nodes of the union type to get our own representation of a type tree.\nOnce we have our own representation of the union subtypes, we can intersect the array of attributes so we keep the common ones.\nThe common attributes will be in all concrete types and they will also be part of the interface as methods to be implemented by the concrete types.\nEmbedding types If you look close to the official API, the type contains a lot of embedded structs, which have no name. My first implementation consisted on simply embedding types as the official API did, giving them no name. This worked very well and I was able to generate most of the content easily.\nBut, as you could have imagined, it couldn‚Äôt be perfect. Yes, the types followed the API definitions. Although, being able to have a small codebase and reusing common structs is a good practice that I couldn‚Äôt just ignore.\nEmbedding 100 times the definition of a RichText (text with formatting, links, etc.) is probably the worst decision you can make. Take in mind that you couldn‚Äôt be able to write any function that processed the RichText, and creating an interface would be impossible because of the unnamed types.\nSo‚Ä¶ I had to follow another path, I called it context naming.\nContext naming Context naming is a solution for assigning names for unnamed embedded structs. To do so, we use the closest name we can find to be related with the type. For example:\ntype BlockEmbed struct { Embed struct { URL string } ... } Could be easily converted into:\ntype Embed struct { Url string } type BlockEmbed struct { Embed Embed } In case we found some previously defined type with the same name, we could compare them and check if they contained the same fields. In case of being able to use the existing type or update it with optional attributes, we wouldn‚Äôt need to create this new type.\nIn case the existing type could not be reused or merged, we could add more context to the name, such as BlockEmbedEmbed.\nIf we follow Go‚Äôs name convention, we also need to convert the names generated to Go ones; from snake_case, as the API uses, to CamelCase. Also, some names such as Id or Url are usually used as all uppercases, like ID.\nBad news üòø Okay‚Ä¶ so here is when I decided to leave this project. I didn‚Äôt expect deciding names for the types would become the most tedious task. There are some name conventions in Go, and we also had to follow the style of the API. We could have rewritten a new API implementation using our own name conventions, but the purpose of this project was to automate and simplify (it‚Äôs okay, you can laugh) the existing API implementation instead of starting from zero.\nNot because the task was too difficult, I could have solved name collisions by splitting parent names and taking more context if names collided. It is because I realize an automatic script wouldn‚Äôt think of names as good as a human.\nThink of the last example of embed, but now using the official API definitions. This will generate:\ntype Block interface {} ... type Embed struct { Url string ... } type BlockEmbed struct { Embed Embed ... } In case the types didn‚Äôt match, we will end up with names like BlockEmbedEmbed and trust me, this one is not the worst that could be generated.\nAlso, this is not the main reason I‚Äôm not continuing this project. The main reason is that the original intention of Notion was to make an OpenAPI public definition so the model types, server and client would be generated automatically. This could be used to generate the bindings in Go with just a command using existing tools, such as oapi-codegen.\nClient basics by aoberoi ¬∑ Pull Request #1 ¬∑ makenotion/notion-sdk-js Goals Establish a project / file structure Establish build configuration (TypeScript) Implement some basic client features (the API was established in an internal RFC) Initializing a client insta... https://github.com/makenotion/notion-sdk-js/pull/1#discussion_r617947073 Type predictions for union types by EnixCoda ¬∑ Pull Request #115 ¬∑ makenotion/notion-sdk-js This PR provides prediction functions that distinguish union types, which are frequently used in request return values. It works very well in my own use cases. Usage example (modified examples/data... https://github.com/makenotion/notion-sdk-js/pull/115#issuecomment-877370532 Conclusion Typescript compiler API is an excellent resource to make any kind of inspecting tool for the language; such as looking for bad practices, automated documentation or even generating code.\nAlthough, language translation is not an easy task when dealing with totally different languages and, even worse, paradigms. The translation could be implemented to suit the Notion API by implementing many more heuristics and specific conditions, but waiting for the ‚Äúpromised‚Äù OpenAPI definition may be the smartest solution.\nIt was a great topic to learn about and I hope more languages implement some kind of language inspection tools.\n","wordCount":"1721","inLanguage":"en","image":"https://xzebra.dev/images/posts/prod-files-secure.s3.us-west-2.amazonaws.com_85SE8sZ.png","datePublished":"2021-10-06T22:42:00+07:00","dateModified":"2023-05-13T11:20:00+07:00","author":{"@type":"Person","name":"Zebra"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xzebra.dev/blog/notion_api_definition_translation/"},"publisher":{"@type":"Organization","name":"Zebra","logo":{"@type":"ImageObject","url":"https://xzebra.dev/images/favicon.ico"}}}</script></head><body id="top"><header class="header"><nav class="nav"><ul id="menu" style="margin-left:auto"><li><a href="https://xzebra.dev/" title="whoami"><span>whoami</span></a></li><li><a href="https://xzebra.dev/blog/" title="blog"><span>blog</span></a></li><li><a href="https://xzebra.dev/apps/" title="apps"><span>apps</span></a></li></ul></nav></header><main class="main"><article class="post-single"><header class="post-header"><h1 class="post-title">Notion API definition translation</h1><div></div><div class="post-description">Using Typescript Compiler API to generate Golang structs from official Notion SDK.</div><div class="post-meta"><span title="2021-10-06 22:42:00 +0700 +0700">October 6, 2021</span>¬†¬∑¬†9 min¬†¬∑¬†Zebra</div></header><figure class="entry-cover"><img loading="lazy" src="https://xzebra.dev/images/posts/prod-files-secure.s3.us-west-2.amazonaws.com_85SE8sZ.png" alt=""/></figure><div class="post-content"><p>Sometimes API bindings are not officially generated for all languages. Generating code from an API definition makes the binding process of an API a much more simple process than translating it field by field and function by function. When there is no public API definition, one way to overcome those problems is by translating from official code definitions.</p><h1 id="background">Background<a hidden="" class="anchor" aria-hidden="true" href="#background">#</a></h1><p>This blog is currently being written in Notion and deployed automatically every night in a Github Action. See <a href="https://github.com/xzebra/notion-blog">my last project</a> to know more about this.</p><p>The mentioned project currently uses a library written in Go to communicate with Notion‚Äôs API. Although, this library is being updated by contributing users (not working for Notion) and it makes it hard to stay updated to the official API; and copying definitions by hand introduces many unnoticeable bugs.</p><h1 id="proposed-solution">Proposed Solution<a hidden="" class="anchor" aria-hidden="true" href="#proposed-solution">#</a></h1><p>One possible solution I read was using <a href="https://github.com/wasmerio/wasmer">Wasmer</a> to create bindings to the Typescript API, so any language (that supports Wasmer) could create bindings over that WebAssembly runtime. This solution has portability as its main trait. I automatically discarded this option because, as you could have guessed, it has the extreme overhead of depending on a WebAssembly runtime; which is a lot for such a small API.</p><p>Another solution, proposed by one of the library contributors, was generating the structs based on the official implementation of the API. This would solve all of this problems; and also reduce significantly the amount of time to keep up to date.</p><p></p><div><a target="_blank" rel="noopener noreferrer" class="bookmark" href="https://github.com/jomei/notionapi/issues/10"><div><div class="bookmark-title">Generating structs based on the typescript types from the official JS sdk ¬∑ Issue #10 ¬∑ jomei/notionapi</div><div class="bookmark-description">After going back and forth on #9, it feels like making sure the API reference is properly implemented is a quite meticulous task that is quite error prone and may introduce vicious bugs that will b...</div><div class="bookmark-link"><div>https://github.com/jomei/notionapi/issues/10</div></div></div><div class="bookmark-image"><img src="https://opengraph.githubassets.com/1984050f25bb0c795c54c1faa1c9d2d9682ed0ba719582dc48f2124f2f44da9d/jomei/notionapi/issues/10" alt="" loading="lazy"/></div></a></div>This proposed solution mentioned a really interesting method used by the LSP implementation of Go, <code>gopls</code>. Too keep up with the protocol definition of Language Server Protocol (written in typescript), they use the <a href="https://github.com/Microsoft/TypeScript/wiki/Architectural-Overview">typescript compiler API</a> to inspect the definitions and generate Go code from these.<p></p><p>At first, I thought it was a crazy idea (well, I still think it). But I couldn‚Äôt hold myself from trying to implement it, so here is how it went.</p><h1 id="implementation">Implementation<a hidden="" class="anchor" aria-hidden="true" href="#implementation">#</a></h1><p>There are a lot of questions regarding how to translate Typescript type definitions to have usable code and with the same quality as handmade translations.</p><h2 id="type-aliases">Type aliases<a hidden="" class="anchor" aria-hidden="true" href="#type-aliases">#</a></h2><p>Notion‚Äôs SDK uses Typescript‚Äôs type aliases to define the model types of the communication between client and API.</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="display:flex"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">IdRequest</span> = <span style="color:#66d9ef">string</span> | <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">TextRequest</span> = <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">RichTextItemRequest</span> =
</span></span><span style="display:flex"><span>  | {
</span></span><span style="display:flex"><span>      <span style="color:#a6e22e">text</span>: { <span style="color:#a6e22e">content</span>: <span style="color:#66d9ef">string</span>; <span style="color:#a6e22e">link</span><span style="color:#960050;background-color:#1e0010">?</span>: { <span style="color:#a6e22e">url</span>: <span style="color:#a6e22e">TextRequest</span> } | <span style="color:#a6e22e">null</span> }
</span></span><span style="display:flex"><span>      <span style="color:#66d9ef">type</span><span style="color:#960050;background-color:#1e0010">?</span>: <span style="color:#e6db74">&#34;text&#34;</span>
</span></span><span style="display:flex"><span>      <span style="color:#a6e22e">annotations</span><span style="color:#960050;background-color:#1e0010">?</span>: {
</span></span><span style="display:flex"><span>        <span style="color:#a6e22e">bold</span><span style="color:#960050;background-color:#1e0010">?</span>: <span style="color:#a6e22e">boolean</span>
</span></span><span style="display:flex"><span>        <span style="color:#a6e22e">italic</span><span style="color:#960050;background-color:#1e0010">?</span>: <span style="color:#a6e22e">boolean</span>
</span></span><span style="display:flex"><span>        <span style="color:#a6e22e">strikethrough</span><span style="color:#960050;background-color:#1e0010">?</span>: <span style="color:#a6e22e">boolean</span>
</span></span><span style="display:flex"><span>        <span style="color:#a6e22e">underline</span><span style="color:#960050;background-color:#1e0010">?</span>: <span style="color:#a6e22e">boolean</span>
</span></span><span style="display:flex"><span>        <span style="color:#a6e22e">code</span><span style="color:#960050;background-color:#1e0010">?</span>: <span style="color:#a6e22e">boolean</span>
</span></span><span style="display:flex"><span>        <span style="color:#a6e22e">color</span><span style="color:#960050;background-color:#1e0010">?</span>:
</span></span><span style="display:flex"><span>          | <span style="color:#e6db74">&#34;default&#34;</span>
</span></span><span style="display:flex"><span>          | <span style="color:#e6db74">&#34;gray&#34;</span>
</span></span><span style="display:flex"><span>          | <span style="color:#e6db74">&#34;brown&#34;</span>
</span></span><span style="display:flex"><span>          | <span style="color:#e6db74">&#34;orange&#34;</span>
</span></span><span style="display:flex"><span>          | <span style="color:#e6db74">&#34;yellow&#34;</span>
</span></span><span style="display:flex"><span>          | <span style="color:#e6db74">&#34;green&#34;</span>
</span></span><span style="display:flex"><span>          | <span style="color:#e6db74">&#34;blue&#34;</span>
</span></span><span style="display:flex"><span>          | <span style="color:#e6db74">&#34;purple&#34;</span>
</span></span><span style="display:flex"><span>          | <span style="color:#e6db74">&#34;pink&#34;</span>
</span></span><span style="display:flex"><span>          | <span style="color:#e6db74">&#34;red&#34;</span>
</span></span><span style="display:flex"><span>          | <span style="color:#e6db74">&#34;gray_background&#34;</span>
</span></span><span style="display:flex"><span>          | <span style="color:#e6db74">&#34;brown_background&#34;</span>
</span></span><span style="display:flex"><span>          | <span style="color:#e6db74">&#34;orange_background&#34;</span>
</span></span><span style="display:flex"><span>          | <span style="color:#e6db74">&#34;yellow_background&#34;</span>
</span></span><span style="display:flex"><span>          | <span style="color:#e6db74">&#34;green_background&#34;</span>
</span></span><span style="display:flex"><span>          | <span style="color:#e6db74">&#34;blue_background&#34;</span>
</span></span><span style="display:flex"><span>          | <span style="color:#e6db74">&#34;purple_background&#34;</span>
</span></span><span style="display:flex"><span>          | <span style="color:#e6db74">&#34;pink_background&#34;</span>
</span></span><span style="display:flex"><span>          | <span style="color:#e6db74">&#34;red_background&#34;</span>
</span></span><span style="display:flex"><span>      }
</span></span><span style="display:flex"><span>    }
</span></span><span style="display:flex"><span><span style="color:#f92672">...</span>
</span></span></code></pre></div><p>We can easily loop for each type alias in a file using the compiler API.</p><p>The problem comes with getting the type representation of those. To simplify the AST types, I created two structs: one to hold a type definition and another for attributes definition.</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="display:flex"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">TypeDef</span> {
</span></span><span style="display:flex"><span>    <span style="color:#a6e22e">id?</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex"><span>    <span style="color:#75715e">// type will be defined if it is a basic type.
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">?:</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex"><span>    <span style="color:#75715e">// value will be defined if it is a literal type
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">value?</span>: <span style="color:#66d9ef">any</span>;
</span></span><span style="display:flex"><span>    <span style="color:#75715e">// attributes will be defined if it is a type literal.
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">attributes?</span>: <span style="color:#66d9ef">AttribDef</span>[];
</span></span><span style="display:flex"><span>    <span style="color:#a6e22e">level?</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex"><span>    <span style="color:#a6e22e">isInterface?</span>: <span style="color:#66d9ef">boolean</span>;
</span></span><span style="display:flex"><span>}
</span></span><span style="display:flex"><span>...
</span></span><span style="display:flex"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">AttribDef</span> {
</span></span><span style="display:flex"><span>    <span style="color:#a6e22e">id</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex"><span>    <span style="color:#a6e22e">optional?</span>: <span style="color:#66d9ef">boolean</span>;
</span></span><span style="display:flex"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">TypeDef</span>;
</span></span><span style="display:flex"><span>    <span style="color:#a6e22e">jsonName?</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>First of all, sorry for the all optional properties, but I don‚Äôt know the idiomatic ways. This structs store some useful information about the types: where are they defined, which identifier and even a value if they are a constant.</p><p>The next step seems easy, just navigate the AST recursively storing the types represented with this structs. But reality strikes when you get deeper into Typescript type aliases declarations.</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="display:flex"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">BlockObjectRequest</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex"><span>  <span style="color:#f92672">|</span> {
</span></span><span style="display:flex"><span>      <span style="color:#a6e22e">heading_1</span><span style="color:#f92672">:</span> { <span style="color:#a6e22e">text</span>: <span style="color:#66d9ef">Array</span>&lt;<span style="color:#f92672">RichTextItemRequest</span>&gt; }
</span></span><span style="display:flex"><span>      <span style="color:#66d9ef">type</span><span style="color:#f92672">?:</span> <span style="color:#e6db74">&#34;heading_1&#34;</span>
</span></span><span style="display:flex"><span>      <span style="color:#66d9ef">object</span><span style="color:#f92672">?:</span> <span style="color:#e6db74">&#34;block&#34;</span>
</span></span><span style="display:flex"><span>    }
</span></span><span style="display:flex"><span>  <span style="color:#f92672">|</span> {
</span></span><span style="display:flex"><span>      <span style="color:#a6e22e">heading_2</span><span style="color:#f92672">:</span> { <span style="color:#a6e22e">text</span>: <span style="color:#66d9ef">Array</span>&lt;<span style="color:#f92672">RichTextItemRequest</span>&gt; }
</span></span><span style="display:flex"><span>      <span style="color:#66d9ef">type</span><span style="color:#f92672">?:</span> <span style="color:#e6db74">&#34;heading_2&#34;</span>
</span></span><span style="display:flex"><span>      <span style="color:#66d9ef">object</span><span style="color:#f92672">?:</span> <span style="color:#e6db74">&#34;block&#34;</span>
</span></span><span style="display:flex"><span>    }
</span></span><span style="display:flex"><span>  <span style="color:#f92672">|</span> {
</span></span><span style="display:flex"><span>      <span style="color:#a6e22e">heading_3</span><span style="color:#f92672">:</span> { <span style="color:#a6e22e">text</span>: <span style="color:#66d9ef">Array</span>&lt;<span style="color:#f92672">RichTextItemRequest</span>&gt; }
</span></span><span style="display:flex"><span>      <span style="color:#66d9ef">type</span><span style="color:#f92672">?:</span> <span style="color:#e6db74">&#34;heading_3&#34;</span>
</span></span><span style="display:flex"><span>      <span style="color:#66d9ef">object</span><span style="color:#f92672">?:</span> <span style="color:#e6db74">&#34;block&#34;</span>
</span></span><span style="display:flex"><span>    }
</span></span><span style="display:flex"><span>  <span style="color:#f92672">|</span> {
</span></span><span style="display:flex"><span>      <span style="color:#a6e22e">embed</span><span style="color:#f92672">:</span> { <span style="color:#a6e22e">url</span>: <span style="color:#66d9ef">string</span>; <span style="color:#a6e22e">caption?</span>: <span style="color:#66d9ef">Array</span>&lt;<span style="color:#f92672">RichTextItemRequest</span>&gt; }
</span></span><span style="display:flex"><span>      <span style="color:#66d9ef">type</span><span style="color:#f92672">?:</span> <span style="color:#e6db74">&#34;embed&#34;</span>
</span></span><span style="display:flex"><span>      <span style="color:#66d9ef">object</span><span style="color:#f92672">?:</span> <span style="color:#e6db74">&#34;block&#34;</span>
</span></span><span style="display:flex"><span>    }
</span></span></code></pre></div><p>The code above is an example of a type alias used to define blocks in Notion. For someone who hasn‚Äôt touched Typescript ever (like me until 5 days ago), those vertical lines mean it is a union type.</p><h2 id="union-types">Union types<a hidden="" class="anchor" aria-hidden="true" href="#union-types">#</a></h2><p>A union type is a type that can be any of the sub-types in the union. Trying to express the concept of a union type is difficult in Go.</p><p>What it is being done in the Go version of the API is defining an interface type <code>Block</code> and implement concrete types for each of the sub-types of the union, such as <code>Heading1</code>, <code>Heading2</code>‚Ä¶ Those concrete types implement the interface.</p><p>The important concept of this is that we have to extract an interface with the common attributes of the union (in the previous example, type and object attributes). Also, we will later have to decide the name of the concrete types.</p><h3 id="creating-the-interface">Creating the interface<a hidden="" class="anchor" aria-hidden="true" href="#creating-the-interface">#</a></h3><p>In order to create the interface, we will iterate all the children AST nodes of the union type to get our own representation of a type tree.</p><p>Once we have our own representation of the union subtypes, we can intersect the array of attributes so we keep the common ones.</p><p>The common attributes will be in all concrete types and they will also be part of the interface as methods to be implemented by the concrete types.</p><h2 id="embedding-types">Embedding types<a hidden="" class="anchor" aria-hidden="true" href="#embedding-types">#</a></h2><p>If you look close to the official API, the type contains a lot of embedded structs, which have no name. My first implementation consisted on simply embedding types as the official API did, giving them no name. This worked very well and I was able to generate most of the content easily.</p><p>But, as you could have imagined, it couldn‚Äôt be perfect. Yes, the types followed the API definitions. Although, being able to have a small codebase and reusing common structs is a good practice that I couldn‚Äôt just ignore.</p><p>Embedding 100 times the definition of a RichText (text with formatting, links, etc.) is probably the worst decision you can make. Take in mind that you couldn‚Äôt be able to write any function that processed the RichText, and creating an interface would be impossible because of the unnamed types.</p><p>So‚Ä¶ I had to follow another path, I called it <em>context naming</em>.</p><h1 id="context-naming">Context naming<a hidden="" class="anchor" aria-hidden="true" href="#context-naming">#</a></h1><p>Context naming is a solution for assigning names for unnamed embedded structs. To do so, we use the closest name we can find to be related with the type. For example:</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="display:flex"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">BlockEmbed</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex"><span>    <span style="color:#a6e22e">Embed</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex"><span>        <span style="color:#a6e22e">URL</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex"><span>    }
</span></span><span style="display:flex"><span>    <span style="color:#f92672">...</span>
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>Could be easily converted into:</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="display:flex"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Embed</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex"><span>    <span style="color:#a6e22e">Url</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex"><span>}
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">BlockEmbed</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex"><span>    <span style="color:#a6e22e">Embed</span> <span style="color:#a6e22e">Embed</span>
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>In case we found some previously defined type with the same name, we could compare them and check if they contained the same fields. In case of being able to use the existing type or update it with optional attributes, we wouldn‚Äôt need to create this new type.</p><p>In case the existing type could not be reused or merged, we could add more context to the name, such as <code>BlockEmbedEmbed</code>.</p><p>If we follow Go‚Äôs name convention, we also need to convert the names generated to Go ones; from <em>snake_case</em>, as the API uses, to <em>CamelCase</em>. Also, some names such as <code>Id</code> or <code>Url</code> are usually used as all uppercases, like <code>ID</code>.</p><h2 id="bad-news-">Bad news üòø<a hidden="" class="anchor" aria-hidden="true" href="#bad-news-">#</a></h2><p>Okay‚Ä¶ so here is when I decided to leave this project. I didn‚Äôt expect deciding names for the types would become the most tedious task. There are some name conventions in Go, and we also had to follow the style of the API. We could have rewritten a new API implementation using our own name conventions, but the purpose of this project was to automate and simplify (it‚Äôs okay, you can laugh) the existing API implementation instead of starting from zero.</p><p>Not because the task was too difficult, I could have solved name collisions by splitting parent names and taking more context if names collided. It is because I realize an automatic script wouldn‚Äôt think of names as good as a human.</p><p>Think of the last example of <code>embed</code>, but now using the official API definitions. This will generate:</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="display:flex"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Block</span> <span style="color:#66d9ef">interface</span> {}
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#f92672">...</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Embed</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex"><span>    <span style="color:#a6e22e">Url</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex"><span>    <span style="color:#f92672">...</span>
</span></span><span style="display:flex"><span>}
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">BlockEmbed</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex"><span>    <span style="color:#a6e22e">Embed</span> <span style="color:#a6e22e">Embed</span>
</span></span><span style="display:flex"><span>    <span style="color:#f92672">...</span>
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>In case the types didn‚Äôt match, we will end up with names like <code>BlockEmbedEmbed</code> and trust me, this one is not the worst that could be generated.</p><p>Also, this is not the main reason I‚Äôm not continuing this project. The main reason is that the original intention of Notion was to make an OpenAPI public definition so the model types, server and client would be generated automatically. This could be used to generate the bindings in Go with just a command using existing tools, such as <a href="https://github.com/deepmap/oapi-codegen">oapi-codegen</a>.</p><p></p><div><a target="_blank" rel="noopener noreferrer" class="bookmark" href="https://github.com/makenotion/notion-sdk-js/pull/1#discussion_r617947073"><div><div class="bookmark-title">Client basics by aoberoi ¬∑ Pull Request #1 ¬∑ makenotion/notion-sdk-js</div><div class="bookmark-description">Goals
Establish a project / file structure
Establish build configuration (TypeScript)
Implement some basic client features (the API was established in an internal RFC)
Initializing a client insta...</div><div class="bookmark-link"><div>https://github.com/makenotion/notion-sdk-js/pull/1#discussion_r617947073</div></div></div><div class="bookmark-image"><img src="https://opengraph.githubassets.com/a777ef56de2807a2752aafd57d210cf299324b7233d5bebe0c82a0f0eef2a8e3/makenotion/notion-sdk-js/pull/1" alt="" loading="lazy"/></div></a></div><div><a target="_blank" rel="noopener noreferrer" class="bookmark" href="https://github.com/makenotion/notion-sdk-js/pull/115#issuecomment-877370532"><div><div class="bookmark-title">Type predictions for union types by EnixCoda ¬∑ Pull Request #115 ¬∑ makenotion/notion-sdk-js</div><div class="bookmark-description">This PR provides prediction functions that distinguish union types, which are frequently used in request return values. It works very well in my own use cases.
Usage example (modified examples/data...</div><div class="bookmark-link"><div>https://github.com/makenotion/notion-sdk-js/pull/115#issuecomment-877370532</div></div></div><div class="bookmark-image"><img src="https://opengraph.githubassets.com/5413b31fc3a5037c562c081dc13179fb9d73046cbd6f98b9b0cb805f0846e8e6/makenotion/notion-sdk-js/pull/115" alt="" loading="lazy"/></div></a></div><p></p><h1 id="conclusion">Conclusion<a hidden="" class="anchor" aria-hidden="true" href="#conclusion">#</a></h1><p>Typescript compiler API is an excellent resource to make any kind of inspecting tool for the language; such as looking for bad practices, automated documentation or even generating code.</p><p>Although, language translation is not an easy task when dealing with totally different languages and, even worse, paradigms. The translation could be implemented to suit the Notion API by implementing many more heuristics and specific conditions, but waiting for the ‚Äúpromised‚Äù OpenAPI definition may be the smartest solution.</p><p>It was a great topic to learn about and I hope more languages implement some kind of language inspection tools.</p></div><footer class="post-footer"><ul class="post-tags"><li><a href="https://xzebra.dev/tags/notion/">notion</a></li><li><a href="https://xzebra.dev/tags/api/">api</a></li><li><a href="https://xzebra.dev/tags/translation/">translation</a></li><li><a href="https://xzebra.dev/tags/golang/">golang</a></li><li><a href="https://xzebra.dev/tags/typescript/">typescript</a></li></ul><div class="share-buttons"><a target="_blank" rel="noopener noreferrer" aria-label="share Notion API definition translation on twitter" href="https://twitter.com/intent/tweet/?text=Notion%20API%20definition%20translation&amp;url=https%3a%2f%2fxzebra.dev%2fblog%2fnotion_api_definition_translation%2f&amp;hashtags=notion%2capi%2ctranslation%2cgolang%2ctypescript"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"></path></svg></a><a target="_blank" rel="noopener noreferrer" aria-label="share Notion API definition translation on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fxzebra.dev%2fblog%2fnotion_api_definition_translation%2f&amp;title=Notion%20API%20definition%20translation&amp;summary=Notion%20API%20definition%20translation&amp;source=https%3a%2f%2fxzebra.dev%2fblog%2fnotion_api_definition_translation%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"></path></svg></a><a target="_blank" rel="noopener noreferrer" aria-label="share Notion API definition translation on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fxzebra.dev%2fblog%2fnotion_api_definition_translation%2f&amp;title=Notion%20API%20definition%20translation"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"></path></svg></a><a target="_blank" rel="noopener noreferrer" aria-label="share Notion API definition translation on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fxzebra.dev%2fblog%2fnotion_api_definition_translation%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"></path></svg></a><a target="_blank" rel="noopener noreferrer" aria-label="share Notion API definition translation on whatsapp" href="https://api.whatsapp.com/send?text=Notion%20API%20definition%20translation%20-%20https%3a%2f%2fxzebra.dev%2fblog%2fnotion_api_definition_translation%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"></path></svg></a><a target="_blank" rel="noopener noreferrer" aria-label="share Notion API definition translation on telegram" href="https://telegram.me/share/url?text=Notion%20API%20definition%20translation&amp;url=https%3a%2f%2fxzebra.dev%2fblog%2fnotion_api_definition_translation%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"></path></svg></a></div></footer></article></main><a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"></path></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>